"use strict";

var req = require('request'),
    util = require('util'),
    websocket = require('websocket').client,
    fs = require('fs'),
    os = require('os').platform(),
    zlib = require('zlib'),
    EE = require('events');
/* Discord Client Method
 * Options (Array Object)
 *  - token: bot authoriazation token
 *  - email: user email address
 *  - password: user password
 *  - debug: set to true for logging output (default: false)
 */
var DiscordClient = function (options){
  var self = this;
  EE.EventEmitter.call(self);

  //Declare all public variables
  var ws, connected = false;

  //Initializing
  function init(){
    debug("Running discordClient on "+os);
    self.servers = {};
    self.internals = {};

    getToken();
  }

  function getToken(){
    if(options.token) return getGateway();

    //TODO user login oauth2 protocol
  }

  function getGateway(){
    debug("GETing Gateway Server");
    req.get({url: "https://discordapp.com/api/gateway", json: true}, function(err, res, data){
      if(res.statusCode != 200 || err){
        debug("Error Occured Obtaining Gateway Server: "+res.statusCode+" "+res.statusMessage);
        return self.emit("disconnect");
      }
      return startConnecting(data.url);
    });
  }

  function startConnecting(gateway){
    self.internals.gateway = gateway;
    self.internals.token = options.token;
    debug("Gateway Server: "+gateway);
    ws = new websocket();
    ws.connect(gateway, null);

    ws.on("connectFailed", handleWSFailure);
    ws.on("connect", handleWSConnection);

  }

  /*Handle WS Events*/
  function handleWSFailure(err){
    debug("Error Occured Connecting to Gateway Server: "+err.toString());
    return self.emit("disconnect");
  }

  function handleWSError(err){
    debug("Error Occured Whilst Communicating with the Gateway Server: "+err.toString());
  }

  function handleWSClose(){
    debug("Connection to Gateway Server has CLOSED");
    return self.emit("disconnect");
  }

  function handleWSConnection(conn){
    debug("Connected to Gateway Server");
    //send identity package
    var identityPackage = {
      "op": 2,
      "d": {
        "token": self.internals.token,
        "properties": {
            "$os": os,
            "$browser": "discordClient",
            "$device": "discordClient",
            "$referrer": "",
            "$referring_domain": ""
        },
        "compress": !!zlib.inflateSync,
        "large_threshold": 250
      }
    }

    conn.send(JSON.stringify(identityPackage));

    conn.on("message",handleWSMessage);
    conn.on("error",handleWSError);
    conn.on("close",handleWSClose);
  }

  function handleWSMessage(data){
    debug("Gateway Server Sent Frame");
    var msg = (data.type === 'binary') ? JSON.parse(zlib.inflateSync(data.binaryData).toString()) : JSON.parse(data.utf8Data);
    console.log(msg);
  }


  //Util
  function debug(msg){
    if(options.debug){
      var d = new Date();
      var time = "["+d.getDate()+"/"+(parseInt(d.getMonth())+1)+"/"+d.getFullYear()+" "+d.toLocaleTimeString()+"] ";
      console.log(time+msg);
    }
  }

  self.connect = function(){
    self.emit("connecting");
    if(!self.connected) return init();
  }

  self.connect();

}

util.inherits(DiscordClient, EE.EventEmitter);
module.exports = DiscordClient;
